# System Architecture

**Project:** ClaudeKit Documentation
**Version:** 1.0
**Last Updated:** 2025-10-18
**Status:** Active

---

## Overview

ClaudeKit Documentation is a static site generator (SSG) application built on Astro v5, deployed as containerized microservice on Kubernetes. The architecture prioritizes performance, scalability, and developer experience through a modern JAMstack approach with AI-enhanced features.

**Architecture Pattern:** JAMstack (JavaScript, APIs, Markup)
**Deployment Model:** Containerized microservice (Docker + Kubernetes)
**Scaling Strategy:** Horizontal pod autoscaling

---

## System Diagram

### High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         Users                                │
│                  (Web Browsers, Mobile)                      │
└────────────────────────┬────────────────────────────────────┘
                         │ HTTPS (TLS 1.3)
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                    CDN Layer (Future)                        │
│              (CloudFlare, AWS CloudFront)                    │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│              nginx Ingress Controller                        │
│        (Load Balancing, TLS Termination, Routing)           │
│                                                              │
│  - Host: docs.claudekit.cc                                   │
│  - Certificate: Let's Encrypt (cert-manager)                 │
│  - Redirect: HTTP → HTTPS                                    │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│            Kubernetes Service (ClusterIP)                    │
│                                                              │
│  Type: ClusterIP                                             │
│  Port: 80 → 3000                                             │
│  Selector: app=claudekit-docs                                │
└────────────────────────┬────────────────────────────────────┘
                         │
                ┌────────┴────────┐
                ▼                 ▼
        ┌──────────────┐  ┌──────────────┐
        │   Pod 1      │  │   Pod 2      │
        │              │  │              │
        │  ┌────────┐  │  │  ┌────────┐  │
        │  │ Node.js│  │  │  │ Node.js│  │
        │  │  v20   │  │  │  │  v20   │  │
        │  │  +     │  │  │  │  +     │  │
        │  │ serve  │  │  │  │ serve  │  │
        │  └────────┘  │  │  └────────┘  │
        │              │  │              │
        │  /dist       │  │  /dist       │
        │  (Static     │  │  (Static     │
        │   Files)     │  │   Files)     │
        │              │  │              │
        │  Port: 3000  │  │  Port: 3000  │
        └──────────────┘  └──────────────┘
                │                 │
                └────────┬────────┘
                         │
                         ▼
        ┌────────────────────────────────┐
        │   External Services (Future)   │
        │                                │
        │  - OpenRouter API (AI)         │
        │  - Analytics (Plausible)       │
        │  - Error Tracking (Sentry)     │
        └────────────────────────────────┘
```

---

## Component Architecture

### Frontend Layer

#### Static HTML/CSS/JS (Build Output)

**Generated by Astro build process:**

```
dist/
├── index.html                  # Homepage
├── docs/
│   ├── getting-started/
│   │   ├── introduction/index.html
│   │   ├── installation/index.html
│   │   └── quick-start/index.html
│   └── cli/
│       ├── index.html
│       ├── installation/index.html
│       └── new/index.html
├── _astro/
│   ├── *.css                   # Minified CSS bundles
│   └── *.js                    # Minified JS bundles (React islands)
└── assets/
    ├── images/
    └── fonts/
```

**Characteristics:**
- Pre-rendered HTML (no server-side rendering)
- Optimized CSS (Tailwind + custom variables)
- Minimal JavaScript (only interactive components)
- Optimized images (WebP/AVIF + PNG fallback)

#### Interactive Components (React Islands)

**Hydration Strategy:**

```typescript
// AIPanel only hydrates when page is idle
<AIChat client:idle />

// Navigation hydrates immediately
<Sidebar client:load />

// Search hydrates when visible
<SearchBox client:visible />
```

**Why Islands Architecture?**
- **Performance:** Only interactive parts use JavaScript
- **SEO:** Static HTML for search engines
- **Progressive Enhancement:** Works without JS, enhanced with JS

### Build-Time Layer (Astro)

#### Content Collections

**Type-Safe Content Management:**

```typescript
// src/content/config.ts
import { defineCollection, z } from 'astro:content';

const docs = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    description: z.string(),
    category: z.enum(['getting-started', 'cli', 'core-concepts', 'components', 'api-reference']),
    order: z.number().optional(),
    published: z.boolean().default(true),
  }),
});
```

**Benefits:**
- TypeScript autocompletion for frontmatter
- Build-time validation (errors caught early)
- Automatic route generation
- Type-safe queries

#### Markdown Processing Pipeline

```
Markdown File (.md)
       ↓
   Frontmatter Parsing (Zod validation)
       ↓
   Remark Plugins (GFM, Math)
       ↓
   Markdown → HTML (unified)
       ↓
   Rehype Plugins (Slug, Autolink, KaTeX)
       ↓
   Syntax Highlighting (Shiki - One Dark Pro)
       ↓
   Astro Layout Wrapper
       ↓
   Static HTML Output
```

**Plugins in Pipeline:**
1. `remark-gfm` - GitHub Flavored Markdown (tables, task lists, strikethrough)
2. `remark-math` - Math notation support ($inline$ and $$blocks$$)
3. `rehype-slug` - Auto-generate heading IDs (e.g., `#installation`)
4. `rehype-autolink-headings` - Add anchor links to headings
5. `rehype-katex` - Render LaTeX math equations

---

## Deployment Architecture

### Container Layer (Docker)

#### Multi-Stage Build

**Stage 1: Builder**

```dockerfile
FROM node:20-alpine AS builder
WORKDIR /app

# Dependency installation
COPY package*.json ./
RUN npm ci

# Build static site
COPY . .
RUN npm run build
```

**Output:** `/app/dist` directory with static files

**Stage 2: Runner**

```dockerfile
FROM node:20-alpine AS runner
WORKDIR /app

# Install static file server
RUN npm install -g serve

# Copy built files
COPY --from=builder /app/dist ./dist

# Expose port
EXPOSE 3000

# Start server
CMD ["serve", "-s", "dist", "-l", "3000"]
```

**Benefits:**
- Small final image (<100MB)
- No build dependencies in production
- Fast startup (<2s)
- Simple static file serving

### Orchestration Layer (Kubernetes)

#### Pod Configuration

**Deployment Spec:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: claudekit-docs
spec:
  replicas: 2  # High availability
  selector:
    matchLabels:
      app: claudekit-docs
  template:
    metadata:
      labels:
        app: claudekit-docs
    spec:
      containers:
        - name: claudekit-docs
          image: ghcr.io/claudekit/claudekit-docs:latest
          ports:
            - containerPort: 3000
          resources:
            requests:
              cpu: 100m      # 0.1 CPU cores
              memory: 128Mi  # 128 MB
            limits:
              cpu: 500m      # 0.5 CPU cores
              memory: 512Mi  # 512 MB
          livenessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 10
```

**Resource Allocation:**
- **Requests:** Guaranteed resources (scheduling basis)
- **Limits:** Maximum allowed resources (prevents runaway)

**Health Checks:**
- **Liveness:** Restart if unresponsive (30s interval)
- **Readiness:** Remove from load balancer if not ready (10s interval)

#### Service Configuration

**ClusterIP Service:**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: claudekit-docs
spec:
  type: ClusterIP  # Internal only (ingress exposes externally)
  ports:
    - port: 80          # Service port
      targetPort: 3000  # Container port
      protocol: TCP
  selector:
    app: claudekit-docs
```

**Why ClusterIP?**
- Internal load balancing across pods
- Not directly accessible from internet
- Ingress controller handles external access

#### Ingress Configuration

**nginx Ingress with TLS:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: claudekit-docs
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        - docs.claudekit.cc
      secretName: claudekit-docs-tls  # Auto-generated by cert-manager
  rules:
    - host: docs.claudekit.cc
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: claudekit-docs
                port:
                  number: 80
```

**Features:**
- TLS certificate auto-renewal (Let's Encrypt)
- HTTP → HTTPS redirect (forced SSL)
- Path-based routing (extensible for /api, etc.)
- Load balancing across multiple pods

---

## Data Flow

### Static Content Request

**Sequence Diagram:**

```
User Browser                nginx Ingress              K8s Service                 Pod (serve)
     │                            │                         │                          │
     │──── GET /docs/intro ─────>│                         │                          │
     │                            │                         │                          │
     │                            │─── Route to Service ───>│                          │
     │                            │                         │                          │
     │                            │                         │─── Load Balance ───────>│
     │                            │                         │                          │
     │                            │                         │                          │──┐
     │                            │                         │                          │  │ Read /dist/docs/intro/index.html
     │                            │                         │                          │<─┘
     │                            │                         │                          │
     │                            │                         │<──── HTML Response ──────│
     │                            │                         │                          │
     │                            │<─── Proxy Response ─────│                          │
     │                            │                         │                          │
     │<──── HTML Document ────────│                         │                          │
     │                            │                         │                          │
     │──── GET /assets/main.css ─>│                         │                          │
     │<──── CSS File ─────────────│                         │                          │
     │                            │                         │                          │
     │──── GET /js/islands.js ───>│                         │                          │
     │<──── JS File ──────────────│                         │                          │
     │                            │                         │                          │
     │──┐                         │                         │                          │
     │  │ Hydrate React components│                         │                          │
     │<─┘                         │                         │                          │
```

**Response Times:**
- HTML document: <50ms (cached) / <200ms (uncached)
- CSS/JS assets: <30ms (small bundles)
- Images: <100ms (optimized formats)

### AI Assistant Interaction (Future)

**Sequence Diagram:**

```
User                AIChat (React)         API Route              OpenRouter          Claude API
 │                       │                     │                      │                   │
 │─── Type message ─────>│                     │                      │                   │
 │                       │                     │                      │                   │
 │─── Click Send ───────>│                     │                      │                   │
 │                       │                     │                      │                   │
 │                       │─── POST /api/chat ─>│                      │                   │
 │                       │    {messages, model}│                      │                   │
 │                       │                     │                      │                   │
 │                       │                     │─── POST /chat ─────>│                   │
 │                       │                     │    (OpenAI format)   │                   │
 │                       │                     │                      │                   │
 │                       │                     │                      │─── Completion ──>│
 │                       │                     │                      │    Request        │
 │                       │                     │                      │                   │
 │                       │                     │                      │<─── Stream ───────│
 │                       │                     │                      │    Chunks         │
 │                       │                     │                      │                   │
 │                       │                     │<─── Stream ──────────│                   │
 │                       │                     │    Response          │                   │
 │                       │                     │                      │                   │
 │                       │<─── SSE Stream ─────│                      │                   │
 │                       │    (text/event-     │                      │                   │
 │                       │     stream)          │                      │                   │
 │                       │                     │                      │                   │
 │                       │──┐                  │                      │                   │
 │<─── Display ──────────│  │ Append chunks   │                      │                   │
 │     Response          │<─┘                  │                      │                   │
```

**Components:**
1. **AIChat Component:** UI for chat interface
2. **API Route:** Server-side proxy to OpenRouter
3. **OpenRouter:** Multi-model gateway
4. **Claude API:** LLM provider (or GPT-4, etc.)

---

## Security Architecture

### Network Security

**Layers of Protection:**

```
Internet
   │
   ▼
┌──────────────────────────┐
│   nginx Ingress          │
│   - TLS Termination      │ ◄── Certificate validation
│   - Rate Limiting        │ ◄── DDoS protection
│   - WAF (Future)         │
└──────────────────────────┘
   │
   ▼
┌──────────────────────────┐
│   Kubernetes Network     │
│   - Network Policies     │ ◄── Pod-to-pod isolation
│   - Service Mesh (Future)│
└──────────────────────────┘
   │
   ▼
┌──────────────────────────┐
│   Application (serve)    │
│   - No exposed secrets   │
│   - Read-only filesystem │
└──────────────────────────┘
```

### API Security (Future)

**Authentication Flow:**

```
User Request
     │
     ▼
┌──────────────────────┐
│  API Route Handler   │
│                      │
│  1. Extract API key  │
│  2. Validate format  │
│  3. Rate limit check │
│  4. Sanitize input   │
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  OpenRouter Client   │
│                      │
│  - Server-side only  │
│  - Secure API key    │
└──────────────────────┘
```

**Security Measures:**
- API keys stored in Kubernetes Secrets
- Rate limiting: 20 requests/minute per IP
- Input sanitization: DOMPurify for user text
- CORS: Restricted to docs.claudekit.cc
- CSP headers: Prevent XSS attacks

---

## Scaling Strategy

### Horizontal Pod Autoscaling (HPA)

**Configuration:**

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: claudekit-docs-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: claudekit-docs
  minReplicas: 2   # Minimum for high availability
  maxReplicas: 10  # Maximum under heavy load
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70  # Scale at 70% CPU
```

**Scaling Behavior:**

```
Traffic Pattern          Pod Count     CPU Usage
──────────────────────────────────────────────────
Low (100 req/min)        2 pods        ~20%
Medium (1000 req/min)    4 pods        ~60%
High (5000 req/min)      8 pods        ~75%
Peak (10000 req/min)     10 pods       ~80%
```

### CDN Integration (Future)

**CloudFlare Architecture:**

```
User Request
     │
     ▼
┌──────────────────────────┐
│   CloudFlare CDN         │ ◄── Cache static assets
│   - HTML caching (5 min) │     (HTML, CSS, JS, images)
│   - Asset caching (1 day)│
│   - Gzip/Brotli compress │
└──────────────────────────┘
     │ Cache miss
     ▼
┌──────────────────────────┐
│   nginx Ingress          │
│   (Origin server)        │
└──────────────────────────┘
```

**Benefits:**
- Reduced latency (edge locations worldwide)
- Lower K8s load (static assets served from CDN)
- Automatic DDoS protection
- Bandwidth savings

---

## Monitoring & Observability

### Health Checks

**Endpoint:** `GET /`

**Liveness Probe:**
- **Purpose:** Detect if pod is alive (restart if not)
- **Interval:** Every 30 seconds
- **Timeout:** 5 seconds
- **Failure Threshold:** 3 consecutive failures

**Readiness Probe:**
- **Purpose:** Detect if pod can accept traffic
- **Interval:** Every 10 seconds
- **Timeout:** 3 seconds
- **Failure Threshold:** 3 consecutive failures

**Why Different?**
- Liveness: Conservative (avoid unnecessary restarts)
- Readiness: Aggressive (quickly remove unhealthy pods from load balancer)

### Logging Architecture (Future)

```
Application Logs
     │
     ▼
┌──────────────────────┐
│  stdout/stderr       │
│  (Container logs)    │
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  Kubernetes API      │
│  (kubectl logs)      │
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  Log Aggregation     │
│  (Loki, ELK Stack)   │
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  Visualization       │
│  (Grafana, Kibana)   │
└──────────────────────┘
```

### Metrics (Future)

**Prometheus Metrics:**

```yaml
# Application metrics
http_requests_total{path="/docs/intro", status="200"}
http_request_duration_seconds{path="/docs/intro", quantile="0.95"}
ai_chat_requests_total{model="claude-3.5-sonnet"}
ai_chat_duration_seconds{model="claude-3.5-sonnet", quantile="0.99"}

# Infrastructure metrics
kube_pod_container_resource_requests_cpu_cores
kube_pod_container_resource_limits_memory_bytes
nginx_ingress_controller_requests{host="docs.claudekit.cc"}
```

**Grafana Dashboards:**
- Application performance (requests, latency, errors)
- Infrastructure health (CPU, memory, network)
- AI usage metrics (requests, costs, models)
- User analytics (page views, popular content)

---

## Disaster Recovery

### Backup Strategy

**Static Content:**
- **Primary:** Git repository (single source of truth)
- **Deployment:** Rebuild from source on any infrastructure

**No Traditional Backups Needed:**
- Stateless architecture (no databases)
- Immutable deployments (Docker images)
- Reproducible builds (package-lock.json)

### Rollback Strategy

**Kubernetes Deployment Rollback:**

```bash
# Check deployment history
kubectl rollout history deployment/claudekit-docs

# Rollback to previous version
kubectl rollout undo deployment/claudekit-docs

# Rollback to specific revision
kubectl rollout undo deployment/claudekit-docs --to-revision=3
```

**Zero-Downtime Rollback:**
- Rolling update strategy (default)
- Readiness probes ensure new pods are ready
- Old pods remain until new pods pass health checks

### High Availability

**Current Configuration:**
- 2 replicas minimum (different nodes if possible)
- Liveness probes restart unhealthy pods
- Readiness probes remove unhealthy pods from load balancer
- Service load balances across healthy pods

**Expected Uptime:** 99.9% (downtime <8.76 hours/year)

---

## Performance Optimization

### Build-Time Optimizations

**Astro Build Process:**

```
Source Code
     │
     ▼
┌──────────────────────┐
│  Static Analysis     │ ◄── Dead code elimination
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  Component Bundling  │ ◄── Code splitting per page
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  CSS Optimization    │ ◄── Tailwind purge, minification
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  Image Optimization  │ ◄── WebP/AVIF conversion
└──────────────────────┘
     │
     ▼
┌──────────────────────┐
│  HTML Minification   │ ◄── Remove whitespace, comments
└──────────────────────┘
     │
     ▼
   /dist/
```

### Runtime Optimizations

**Static File Serving (`serve`):**
- Gzip/Brotli compression (automatic)
- Cache-Control headers (1 year for assets)
- ETag support (efficient caching)

**Browser Caching:**

```
Resource Type        Cache Duration
──────────────────────────────────
HTML                 5 minutes
CSS/JS (hashed)      1 year
Images (hashed)      1 year
Fonts                1 year
```

**Why Different TTLs?**
- HTML: Short cache (fresh content)
- Assets: Long cache (immutable filenames with hashes)

---

## Technology Stack Summary

### Frontend
- **Framework:** Astro v5.14.6 (SSG)
- **UI Library:** React 18.3.1 (islands)
- **Styling:** Tailwind CSS v3.4.17 + CSS Variables
- **Typography:** Inter Variable, Geist Mono

### Content
- **Format:** Markdown with frontmatter (Zod validation)
- **Processing:** Unified (remark + rehype)
- **Syntax Highlighting:** Shiki (One Dark Pro)

### Infrastructure
- **Container:** Docker (node:20-alpine)
- **Orchestration:** Kubernetes v1.24+
- **Ingress:** nginx-ingress-controller
- **Certificates:** cert-manager + Let's Encrypt
- **Registry:** GitHub Container Registry

### External Services (Future)
- **AI:** OpenRouter API (multi-model gateway)
- **Analytics:** Plausible or similar (privacy-focused)
- **Monitoring:** Prometheus + Grafana
- **Logging:** Loki + Grafana
- **Errors:** Sentry

---

## Architectural Decisions

### ADR-001: Static Site Generation over SSR

**Decision:** Use Astro SSG (static), not Next.js SSR (server-side rendering)

**Rationale:**
- **Performance:** Pre-rendered HTML faster than runtime rendering
- **Simplicity:** No server-side runtime complexity
- **Cost:** Static hosting cheaper than server instances
- **SEO:** Pre-rendered HTML better for search engines

**Trade-offs Accepted:**
- No dynamic data without client-side JS
- Build time increases with content (mitigated by incremental builds)

### ADR-002: Kubernetes over Serverless

**Decision:** Deploy on Kubernetes, not serverless (Vercel, Netlify)

**Rationale:**
- **Control:** Full infrastructure control
- **Cost:** Predictable pricing (no per-request billing)
- **Flexibility:** Can add APIs, databases later
- **Learning:** Team expertise in K8s

**Trade-offs Accepted:**
- More complex infrastructure management
- Need to manage scaling, monitoring

### ADR-003: OpenRouter over Direct AI APIs

**Decision:** Use OpenRouter as AI gateway, not direct Claude/GPT-4 APIs

**Rationale:**
- **Flexibility:** Switch models without code changes
- **Fallbacks:** Automatic failover to alternative models
- **Cost Optimization:** Route to cheapest model for task
- **Simplicity:** Single API interface for 400+ models

**Trade-offs Accepted:**
- Additional latency (proxy layer)
- Dependency on third-party service

### ADR-004: React Islands over Full React App

**Decision:** Use Astro islands architecture, not full React SPA

**Rationale:**
- **Performance:** Minimal JS payload (<50KB vs. >500KB)
- **SEO:** Static HTML for content
- **Progressive Enhancement:** Works without JS
- **Simplicity:** Less state management complexity

**Trade-offs Accepted:**
- No shared state across islands (without workarounds)
- Complex interactions may be harder to implement

---

## Future Architecture Considerations

### Phase 2: API Routes

**Planned Architecture:**

```
src/pages/api/
├── chat.ts          # AI chat endpoint
├── search.ts        # AI-powered search
└── feedback.ts      # User feedback submission
```

**Implementation:**
- Server-side API routes (Astro endpoints)
- OpenRouter client for AI requests
- Rate limiting middleware
- Input validation (Zod)

### Phase 3: Search Integration

**Pagefind Architecture:**

```
Build Time                 Runtime
──────────────────────────────────
Markdown → HTML           Browser
     │                        │
     ▼                        ▼
Pagefind indexer          Search index
     │                     (lazy loaded)
     ▼                        │
search-index.json            ▼
search-data.json          Search UI
```

**Benefits:**
- Zero backend infrastructure
- Instant client-side search
- Works offline after initial load
- ~1KB initial payload

### Phase 4: Analytics Integration

**Privacy-Focused Analytics:**

```
User Event                Plausible API           Dashboard
     │                         │                      │
     │─── Page view ─────────>│                      │
     │─── Click event ───────>│                      │
     │                         │                      │
     │                         │─── Aggregated ─────>│
     │                         │    Data              │
```

**Principles:**
- No cookies
- No PII collection
- GDPR compliant
- Aggregate metrics only

---

## Conclusion

The ClaudeKit Documentation architecture balances:
- **Performance:** Static generation + minimal JS
- **Scalability:** Kubernetes horizontal scaling
- **Maintainability:** Simple Docker deployment
- **Future-Proof:** Extensible for APIs, search, analytics

**Next Steps:**
1. Implement CI/CD pipeline
2. Add monitoring and logging
3. Connect AI assistant backend
4. Integrate search (Pagefind)
5. Set up analytics

---

*Last updated: 2025-10-18*
*Review this document when adding major architectural components or making significant infrastructure changes.*
